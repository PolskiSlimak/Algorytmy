#include <iostream>
#include <stdio.h>

using namespace std;

struct elem { //pojemnik na liczby
    int data;    
    elem* next; //tutaj zapisujemy adres kolejnego elementu listy
	elem* prev; //a tutaj poprzedniego
};

int how_many(elem* list){ //przekazujemy adres pierwszego elementu listy przez wartość (kopia, nie modyfikujemy tego adresu)
	int i = 0;
	while (list != NULL){ //list to jest adres czy ten element?
		list = list->next;
		i++;
	}
	return i;
}

void add_any_position (int data, int position, elem*& list) { //podajemy co chcemy dodać, na którą pozycję i przekazujemy adres przez referencję (czyli operujemy na prawdziwym adresie, a nie kopii)
	if (list == NULL){ //jeśli lista nie istnieje
		elem* first = new elem; //tworzymy pierwszy element
		first->data = data; //do pola data pierwszego obiektu wstawiamy podaną liczbę
		first->next = NULL; //pole next pierwszego elementu nie zawiera żadnego adresu, czyli obiekt nie pokazuje na następny
		first->prev = NULL; //pole prev pierwszego elementu nie zawiera żadnego adresu, czyli obiekt nie pokazuje na poprzedni
		list = first; //utoworzony obiekt jest adresem listy
		return;
	}
	if (position == 1) { //jeśli chcemy dodać obiekt z lewej strony
		elem* temp = new elem; //tworzymy ten obiekt
		temp->data = data; 
		temp->next = list;
		temp->prev = NULL; //jest pierwszy na liście, więc nie pokazuje na żaden poprzedni
		list->prev = temp; //musimy ustawić żeby element przed który wstawiamy nasz obiekt pokazywał na niego jako na poprzedni, czyli do jego preva obiektu list dajemy adres tempa
		list = temp; //ustawiamy, że adresem listy jest adres obiektu prev
	}else if(position > 1 && (how_many(list) >= position)){ //a jakby tutaj zrobić > zamiast >= to można by wywalić tego ifa z za krótką listą
		elem* temp = new elem;
		temp->data = data;
		int counter = 1;
		elem* back = list; //wskaźnik na pierwszy element listy
		while (counter != (position-1)) { //jeśli chcemy wstawić obiekt na np. 4 pozycję to wskaźnik back zatrzyma się na 3 elemencie
			counter++;
			back = back->next;
			if (back == NULL) { //jak dojedziemy do końca listy i w ostatnim elemencie next będzie puste to back ustawi się na NULL
				cout << "Lista za krotka";
				return;
			}
		}
		temp->next = back->next; //next nowo utworzonego elementu przyjmuje wartość tego, na którym zatrzymał się back, czyli jeśli wsadzamy go na 4 pozycję to pokazuje na 5 element
		temp->prev = back; //do preva nowego elementu dajemy adres tego, na którym zatrzymał się back
		back->next->prev = temp; //prev elementu na pozycji po tym dodanym ma adres tego dodanego, czyli prev następnego obiektu na który wskazuje back
		back->next = temp; //next backa pokazuje na nowy 
	} else if (position > 1) { //a tutaj zrobić position==how_many(list)+1, czyli, że na ostatnią pozycję a potem osobnego elsa, że za lista jest za krótka dla podanej pozycji
		elem* temp = new elem;
		temp->data = data;
		int counter = 1;
		elem* back = list;
		while (counter != (position-1)) {
			counter++;
			back = back->next;
			if (back == NULL) {
				cout << "Lista za krotka";
				return;
			}
		}
		temp->next = back->next;
		temp->prev = back;
		back->next = temp;
	} else {
		cout << "Bledne dane";
	}
			
}

void deletee(int index, elem*& list){
	if(how_many(list) >= index){
		if(list->next == NULL){
			list = NULL;
			delete list;
		}else if(index == 1){
			elem* helper = list->next;
			delete list;
			list = helper;
			list->prev = NULL;
		}else if(index > 1){
			int counter = 0;
			elem* erese = list;
			while(counter != (index-1)){
				counter++;
				erese = erese->next;	
			}
			if(erese->next == NULL){
				elem * prevv = erese->prev;
				delete erese;		
				prevv->next = NULL;
			}else{
				erese->next->prev = erese->prev;
				erese->prev->next = erese->next;
				delete erese;	
			}		
		}
	
	}	
}

void showw (elem* list) {
    	while (list != NULL) {
    		cout << list->data << " ";
			list = list->next; 
		}
}

void reverse(elem* list){
	if (list == NULL){
		return;
	}
	reverse(list->next);
	cout << list->data << " ";

}
void reverse_usingprev(elem* list){
	elem* end = list;
	while (end->next != NULL){
		end = end->next;
	}
	while (end != NULL){
		cout << end->data << " ";
		end = end->prev;
	}	
}
void convert (elem*& list){
	elem* last = list;
	while (last->next != NULL){
		last = last->next;
	}
	last->next = list;
	list->prev = last;
}
int main()
{

	elem* newww = NULL;
	add_any_position(10, 1, newww);
	add_any_position(12, 2, newww);
	add_any_position(13, 2, newww);
	add_any_position(1000, 1, newww);
	add_any_position(20, 1, newww);
	add_any_position(30, 3, newww);
	add_any_position(31, 3, newww);
	add_any_position(14, 2, newww);
	showw(newww);
	deletee(8,newww);
	cout << endl;
	reverse(newww);
	deletee(6,newww);
	cout << endl;
	reverse_usingprev(newww);
	return 0;	
}
