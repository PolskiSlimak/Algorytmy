#include <iostream>

using namespace std;

struct node { // tworzymy strukture
    int data;
    node* left;
    node* right;
};
void add (int data, node*& tree){           // MOZE TAK BEDZIE CZYTELNIEJSZE IDK    
    node* fresh = new node;                 // tworzymy nowa strukture gdzie mozemy wsadzić nasze wartosci
    fresh->data = data;                     // przekazujemy wartosc do wartosci
    fresh->left = NULL;                     // ustawiamy galezie  na null iż nie wiemy co bedzie po prawej lub lewej stronie
    fresh->right = NULL;                    // same
    if(tree != NULL){                       // spprawdzamy czy drzewo jest puuste ten przyapdek rozpatruje ze nie jest puste
        node* prev = tree;                  // zapisujemy poczatek dzrwa aby sie poruszać po nim nie to taki nasz runner albo helper 
        while(prev != NULL){                // dopoki drzewo nie bedzie wskazywac na nulla
            if(fresh->data >= prev->data){  // jesli wartosc naszego nowego elemetu jest wieksza BADZ ROWNA od KORZENIA/wezla n asteponego to idziemy w prawo
                if(prev->right == NULL){    // teraz sprawdzamy czy jest wartosc obok wezla pusta jesli tak to wprowadzamy za nulla nulla napisujemy tak ?
                    prev->right = fresh;    // to nadpisanie tutaj nastepuje
                    break;                  // wychodzimy
                }else{
                    prev = prev->right;     // jesli nie natrafilismy napuste lecimy dalej z koxem tak w kolko 
                }
            }else{                          // tam mielismy wieksze lub = no to tu mniejsze jasna sprawa
                if(prev->left == NULL){     // TA SAMA ZASAda jak wczesniej nie bede komentowac
                    prev->left = fresh;
                    break;
                }else{
                    prev = prev->left;
                }
            }
        }
    }else{                                   // nasze drzewo jest puste czyli nasz swtorzony wezel jest na arzie sam
        tree = fresh;
    }
}
/*void add_rec(int data, node*& tree, node* prev=tree){
    if(tree == NULL){
        node* fresh = new node;
        fresh->data = data;
        fresh->left = NULL;
        fresh->right = NULL;
        tree = fresh;
        return;
    }
    node* fresh = new node;
    fresh->data = data;
    fresh->left = NULL;
    fresh->right = NULL;
    if(fresh->data >= prev->data){
        if(prev->right == NULL){
            prev->right = fresh;
            return;
        }else{
            delete fresh;
            add_rec(data, prev->right);
        }
    }else{
        if(prev->left == NULL){
            prev->left = fresh;
            return;
        }else{
            delete fresh;
            add_rec(data, prev->left);
        }
    }
}*/
void delete_number(int todelete, node*& tree){
    if(tree == NULL){
        cout << "Drzewo puste";
        return;
    }
    if(tree->left == NULL && tree->right == NULL && tree->data == todelete){
        tree = NULL;
        delete tree;
        return;
    }
    node *searcher = tree;
    node* prev = tree;
    while(searcher->data != todelete){
        if(todelete > searcher->data){
            prev = searcher;
            searcher = searcher->right;
        }else if(todelete < searcher->data){
            prev = searcher;
            searcher = searcher->left;
        }
        if(searcher == NULL){
            cout << "nie ma tego elementu w drzewie";
            return;
        }
    }
        if(searcher->left == NULL){
            if(searcher->right == NULL){
                if(prev->left == searcher){
                    prev->left = NULL;
                    delete searcher;
                }else if(prev->right == searcher){
                    prev->right = NULL;
                    delete searcher;
                }
            }else{
                if(prev->left == searcher){
                    prev->left = searcher->right;
                    delete searcher;
                }else if(prev->right == searcher){
                    prev->right = searcher->right;
                    delete searcher;
                }
            }
        }else{
            if(searcher->right == NULL){
                if(prev->left == searcher){
                    prev->left = searcher->left;
                    delete searcher;
                }else if(prev->right == searcher){
                    prev->right = searcher->left;
                    delete searcher;
                }
            }else{
                if(searcher->right->left == NULL){
                    node* pom = searcher->right;
                    searcher->data = searcher->right->data;
                    searcher->right = searcher->right->right;
                    delete pom;
                }else{
                    if(searcher->right->left->right == NULL){
                        node* pom = searcher->right->left;
                        searcher->data = searcher->right->left->data;
                        searcher->right->left = NULL;
                        delete pom;
                    }else{
                        node* pom = searcher->right->left->right;
                        searcher->data = searcher->right->left->data;
                        searcher->right->left->data = searcher->right->left->right->data;
                        searcher->right->left->right = NULL;
                        delete pom;
                    }
                }
            }
        }
}
bool search (int tosearch, node* tree){
    if(tree == NULL){
        return false;
    }
    while(tree != NULL){
        if(tosearch == tree->data){
            return true;
        }else if(tosearch > tree->data){
            tree = tree->right;
        }else if(tosearch < tree->data){
            tree = tree->left;
        }
    }
    return false;
}
bool search_rec(int tosearch, node*tree){
    if(tree == NULL){
        return false;
    }
    if(tosearch == tree->data){
        return true;
    }
    if(tosearch > tree->data){
        search_rec(tosearch, tree->right);
    }else{
        search_rec(tosearch, tree->left);
    }
}
void preorder(node* tree){
    if(tree != NULL){
        cout << tree->data << " ";
        preorder(tree->left);
        preorder(tree->right);
    }
}
void inorder(node* tree){
    if(tree != NULL){
        inorder(tree->left);
        cout << tree->data << " ";
        inorder(tree->right);
    }
}
void postorder(node* tree){
    if(tree != NULL){
        postorder(tree->left);
        postorder(tree->right);
        cout << tree->data << " ";
    }
}
void show_rec(node* tree, int step = 0){
    if(tree!= NULL){
        for(int i = 0; i<step; i++){
            cout << " ";
        }
        cout << tree->data << endl;
        step++;
        show_rec(tree->left, step);
        show_rec(tree->right, step);
    }
}

int main()
{
    node* tree = NULL;
    add(250, tree);
    add(270, tree);
    add(240, tree);
    add(225, tree);
    add(231, tree);
    add(226, tree);
    add(227, tree);
    add(232, tree);
    add(224, tree);
    show_rec(tree);
    cout << endl;
    delete_number(225,tree);
    show_rec(tree);
    /*cout << endl;
    preorder(tree);
    cout << endl;
    inorder(tree);
    cout << endl;
    postorder(tree);*/
}
