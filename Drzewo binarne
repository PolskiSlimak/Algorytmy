#include <iostream>

using namespace std;

struct node { // tworzymy strukture
    int data;
    node* left;
    node* right;
};
void add (int data, node*& tree){                       // MOZE TAK BEDZIE CZYTELNIEJSZE IDK    
    node* fresh = new node;                             // tworzymy nowa strukture gdzie mozemy wsadzić nasze wartosci
    fresh->data = data;                                 // przekazujemy wartosc do wartosci
    fresh->left = NULL;                                 // ustawiamy galezie  na null iż nie wiemy co bedzie po prawej lub lewej stronie
    fresh->right = NULL;                                // same
    if(tree != NULL){                                   // spprawdzamy czy drzewo jest puuste ten przyapdek rozpatruje ze nie jest puste
        node* prev = tree;                              // zapisujemy poczatek dzrwa aby sie poruszać po nim nie to taki nasz runner albo helper 
        while(prev != NULL){                            // dopoki drzewo nie bedzie wskazywac na nulla
            if(fresh->data >= prev->data){              // jesli wartosc naszego nowego elemetu jest wieksza BADZ ROWNA od KORZENIA/wezla n asteponego to idziemy w prawo
                if(prev->right == NULL){                // teraz sprawdzamy czy jest wartosc obok wezla pusta jesli tak to wprowadzamy za nulla nulla napisujemy tak ?
                    prev->right = fresh;                // to nadpisanie tutaj nastepuje
                    break;                              // wychodzimy
                }else{
                    prev = prev->right;                 // jesli nie natrafilismy napuste lecimy dalej z koxem tak w kolko 
                }
            }else{                                      // tam mielismy wieksze lub = no to tu mniejsze jasna sprawa
                if(prev->left == NULL){                 // TA SAMA ZASAda jak wczesniej nie bede komentowac
                    prev->left = fresh;
                    break;
                }else{
                    prev = prev->left;
                }
            }
        }   
    }else{                                              // nasze drzewo jest puste czyli nasz swtorzony wezel jest na arzie sam
        tree = fresh;
    }
}
/*void add_rec(int data, node*& tree, node* prev=tree){ // dodawanie rekurencyjne czyli jak wiemy to wywolywanie funkcji do warunku
    if(tree == NULL){                                   // jesli ddrzewo nie jest puste (ogolnie w tym tree tkwi nasz korzen z reguly) 
        node* fresh = new node;                         // tworzymy sobie wezeł  on bedzie taki bardziej pomomocniczy zeby żonglować wartościami 
        fresh->data = data;                             // do fresha w miejsce gdzie wchodzi wartosci wkladamy wartosc podana przez "uzytkownika"
        fresh->left = NULL;                             // wskazniki na null bo no dodajemy i nie wiemy co bedzie po prawej czy po lewej    
        fresh->right = NULL;                            // same
        tree = fresh;                                   // no i co mamy nasz korzeń przypisujemy go do tree w sensie wsyztskie wartosci kopiujemy automatycznie
        return;                                         //wychodzimy z if'a ???????????????????????????????????????????????
    }
    node* fresh = new node;                             // a to jezli nie jest puste
    fresh->data = data;                                 // jak wyzej 
    fresh->left = NULL;                                 // same
    fresh->right = NULL;                                // same 
    if(fresh->data >= prev->data){                      // to tak jak wyzej te same zasay   
        if(prev->right == NULL){                        //same
            prev->right = fresh;
            return;
        }else{
            delete fresh;                                 //zastanawiasz sie na kij usuwamy fresha no bo po co nam porownujemy wartosc data i jezeli nie znalezlismy musimy znowu utworzyc nowy node ale przejsc w prawo i znou szukac nulla
            add_rec(data, prev->right);                  // tylko tu jest powtorka funkcji bo nie natrafilismy na null'a
        }
    }else{
        if(prev->left == NULL){
            prev->left = fresh;
            return;
        }else{
            delete fresh;                                  //same TAK MI SIE WYDAJE 
            add_rec(data, prev->left);                    // to samo nie natrafilismy na puste miejsce gałąz i musimy robic az znajdziemy
        }
    }
}*/
void delete_number(int todelete, node*& tree){            //dobre lvl up, usuwanie jest spooko ale w ciul duzo warunków na koniec zostawiam to
    if(tree == NULL){
        cout << "Drzewo puste";
        return;
    }
    if(tree->left == NULL && tree->right == NULL && tree->data == todelete){
        tree = NULL;
        delete tree;
        return;
    }
    node *searcher = tree;
    node* prev = tree;
    while(searcher->data != todelete){
        if(todelete > searcher->data){
            prev = searcher;
            searcher = searcher->right;
        }else if(todelete < searcher->data){
            prev = searcher;
            searcher = searcher->left;
        }
        if(searcher == NULL){
            cout << "nie ma tego elementu w drzewie";
            return;
        }
    }
        if(searcher->left == NULL){
            if(searcher->right == NULL){
                if(prev->left == searcher){
                    prev->left = NULL;
                    delete searcher;
                }else if(prev->right == searcher){
                    prev->right = NULL;
                    delete searcher;
                }
            }else{
                if(prev->left == searcher){
                    prev->left = searcher->right;
                    delete searcher;
                }else if(prev->right == searcher){
                    prev->right = searcher->right;
                    delete searcher;
                }
            }
        }else{
            if(searcher->right == NULL){
                if(prev->left == searcher){
                    prev->left = searcher->left;
                    delete searcher;
                }else if(prev->right == searcher){
                    prev->right = searcher->left;
                    delete searcher;
                }
            }else{
                if(searcher->right->left == NULL){
                    node* pom = searcher->right;
                    searcher->data = searcher->right->data;
                    searcher->right = searcher->right->right;
                    delete pom;
                }else{
                    if(searcher->right->left->right == NULL){
                        node* pom = searcher->right->left;
                        searcher->data = searcher->right->left->data;
                        searcher->right->left = NULL;
                        delete pom;
                    }else{
                        node* pom = searcher->right->left->right;
                        searcher->data = searcher->right->left->data;
                        searcher->right->left->data = searcher->right->left->right->data;
                        searcher->right->left->right = NULL;
                        delete pom;
                    }
                }
            }
        }
}
bool search (int tosearch, node* tree){                          // ogolnie tu szukamy liczby w drzewie 
    if(tree == NULL){                                           // jesli drzewo jest nullem to nie ma zadnych wartosci jest puste nie ma DRZEWAA isssEmptyy
        return false;                                           //zwracamy false bo nie ma drzewa
    }   
    while(tree != NULL){                                        // dopoki drzewo nie jest nullem lecimy po kolei
        if(tosearch == tree->data){                             // ogolnie liczba = wchodzimy w struturke treee i wyciagmy z niej 1 z 3 waertosci mianowice data
            return true;                                        // jezeli warunek ok no to super 
        }else if(tosearch > tree->data){                        // jesli nie to znowu porownujemy liczbe z = wartoscia w wezle
            tree = tree->right;                                 // jest wieksza ? lecimy z naszego wezla na prawo z nadzija ze w nastepnym ciegu peli spelni sie warunek nr 1
        }else if(tosearch < tree->data){                        // same tylko dla mniejszej liczby od liczby w wezle
            tree = tree->left;                                  // same jak dwie linijki wyzej tylko ze na lewo
        }   
    }
    return false;                                               // jesli dotrze na koniec i zakonczy petle bo natrafi na nulla to zwrtacmy false bo takiej liczby po prostu nie ma uzytkownik nie mysli
}                                                               // moze jak mu powiemy ze mozg to apka to zacznie go używać ;) Przepraszam musialam to napisac 
bool search_rec(int tosearch, node*tree){                       // ogolnie to jest to samo tylko wywolywanie funkcjido NATRAFIENIA NA nullalub wartosci ktorej szukamy chyba
    if(tree == NULL){                                           // same jak wyzej
        return false;                           
    }   
    if(tosearch == tree->data){                                 // same jak wyzej tylko ze ogolnie tu jest if bo tu warunek sprawdzamy mamy dwie opcje tylko
        return true;
    }
    if(tosearch > tree->data){                                  //to sa ogolnie te dwa warunki ktore nam robia za petle o to sie rozbiega
        search_rec(tosearch, tree->right);                      // wywolywanie znowu tej funkcji tylko zed wezel nam przechodzi na wezel ktory jest na PRAWO
    }else{      
        search_rec(tosearch, tree->left);                       // same tylko ze wezel przechodzi na ten wezel ktory jest na lewo
    }
}
void preorder(node* tree){
    if(tree != NULL){
        cout << tree->data << " ";
        preorder(tree->left);
        preorder(tree->right);
    }
}
void inorder(node* tree){
    if(tree != NULL){
        inorder(tree->left);
        cout << tree->data << " ";
        inorder(tree->right);
    }
}
void postorder(node* tree){
    if(tree != NULL){
        postorder(tree->left);
        postorder(tree->right);
        cout << tree->data << " ";
    }
}
void show_rec(node* tree, int step = 0){
    if(tree!= NULL){
        for(int i = 0; i<step; i++){
            cout << " ";
        }
        cout << tree->data << endl;
        step++;
        show_rec(tree->left, step);
        show_rec(tree->right, step);
    }
}

int main()                                                       // no to jest main
{
    node* tree = NULL;                                           // tu sobie drzewko torzymy ktorej jjest aktualnie puste dalej dodajemy i wywolujemy poszczegolne funkcje
    add(250, tree);                                              // to tlumaczenie sobie daruje 
    add(270, tree);
    add(240, tree);
    add(225, tree);
    add(231, tree);
    add(226, tree);
    add(227, tree);
    add(232, tree);
    add(224, tree);
    show_rec(tree);
    cout << endl;
    delete_number(225,tree);
    show_rec(tree);
    /*cout << endl;
    preorder(tree);
    cout << endl;
    inorder(tree);
    cout << endl;
    postorder(tree);*/
}
